from typing import (
    Any,
    Optional,
    Union,
    TypeVar,
    Iterable,
    List,
    Tuple,
    Callable,
    Iterator,
    Sequence,
    overload,
)

_T = TypeVar('_T')
_U = TypeVar('_U')

def accumulate(
    iterable: Iterable[_T], func: Callable[[_T, _T], _T] = ...
) -> Iterator[_T]: ...
def take(n: int, iterable: Iterable[_T]) -> List[_T]: ...
def tabulate(function: Callable[[_T], _U], start: int = ...) -> Iterator[_U]: ...
def tail(n: int, iterable: Iterable[_T]) -> Iterator[_T]: ...
def consume(iterator: Iterable[Any], n: Optional[int] = ...) -> None: ...
@overload
def nth(iterable: Iterable[_T], n: int) -> Optional[_T]: ...
@overload
def nth(
    iterable: Iterable[_T], n: int, default: Union[_T, _U] = ...
) -> Union[_T, _U]: ...
def all_equal(iterable: Iterable[Any]) -> bool: ...
def quantify(iterable: Iterable[_T], pred: Callable[[_T], bool] = ...) -> int: ...
def padnone(iterable: Iterable[_T]) -> Iterator[Optional[_T]]: ...
def ncycles(iterable: Iterable[_T], n: int) -> Iterator[_T]: ...
def dotproduct(vec1: Iterable[_T], vec2: Iterable[_T]) -> Union[_T, int]: ...
def flatten(listOfLists: Sequence[Sequence[_T]]) -> Iterator[_T]: ...
def repeatfunc(
    func: Callable[..., _T], times: Optional[int] = ..., *args: Any
) -> Iterator[_T]: ...
def pairwise(iterable: Iterable[_T]) -> Iterator[Tuple[_T, _T]]: ...
@overload
def grouper(n: int, iterable: Iterable[_T]) -> List[Tuple[Optional[_T], ...]]: ...
@overload
def grouper(
    n: int, iterable: Iterable[_T], fillvalue: None
) -> List[Tuple[Optional[_T], ...]]: ...
@overload
def grouper(
    n: int, iterable: Iterable[_T], fillvalue: _U
) -> List[Tuple[Union[_T, _U], ...]]: ...
def roundrobin(*iterables: Iterable[_T]) -> Iterator[_T]: ...
def partition(
    pred: Callable[[_T], bool], iterable: Iterable[_T]
) -> Tuple[Iterator[_T], Iterator[_T]]: ...
def powerset(iterable: Iterable[_T]) -> Iterator[Tuple[_T, ...]]: ...
def unique_everseen(
    iterable: Iterable[_T], key: Optional[Callable[[_T], Any]] = ...
) -> Iterator[_T]: ...
def unique_justseen(
    iterable: Iterable[_T], key: Optional[Callable[[_T], Any]] = ...
) -> Iterator[_T]: ...
def iter_except(
    func: Callable[[], _T],
    exception: Exception,
    first: Optional[Callable[[], _T]] = ...,
) -> Iterator[_T]: ...
@overload
def first_true(
    iterable: Iterable[_T], pred: Optional[Callable[[_T], bool]] = ...
) -> Optional[_T]: ...
@overload
def first_true(
    iterable: Iterable[_T], default: _U, pred: Optional[Callable[[_T], bool]] = ...
) -> Union[_T, _U]: ...
def random_product(*args: Iterable[_T], repeat: int = ...) -> Tuple[_T, ...]: ...
def random_permutation(
    iterable: Iterable[_T], r: Optional[int] = ...
) -> Tuple[_T, ...]: ...
def random_combination(iterable: Iterable[_T], r: int) -> Tuple[_T, ...]: ...
def random_combination_with_replacement(
    iterable: Iterable[_T], r: int
) -> Tuple[_T, ...]: ...
def nth_combination(iterable: Iterable[_T], r: int, index: int) -> Tuple[_T, ...]: ...
def prepend(value: _T, iterator: Iterable[_T]) -> Iterator[_T]: ...
