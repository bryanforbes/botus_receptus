# Stubs for asyncpg.protocol.protocol (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Iterator, Tuple, Union, TypeVar, Collection, Optional, Hashable, Sized, overload
from typing_extensions import Protocol as TEProtocol
import asyncio

from ..types import (
    BitString as BitString,
    Point as Point,
    Box as Box,
    Line as Line,
    LineSegment as LineSegment,
    Path as Path,
    Point as Point,
    Polygon as Polygon,
    Circle as Circle
)

NO_TIMEOUT: Any = ...

class CoreProtocol:
    def __init__(self, *args, **kwargs): ...
    def connection_lost(self, *args, **kwargs): ...
    def connection_made(self, *args, **kwargs): ...
    def data_received(self, *args, **kwargs): ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class BaseProtocol(CoreProtocol):
    def __init__(self, *args, **kwargs): ...
    def _create_future_fallback(self, *args, **kwargs): ...
    def _get_timeout(self, *args, **kwargs): ...
    def _on_timeout(self, *args, **kwargs): ...
    def _on_waiter_completed(self, *args, **kwargs): ...
    def _request_cancel(self, *args, **kwargs): ...
    def abort(self, *args, **kwargs): ...
    def bind(self, *args, **kwargs): ...
    def bind_execute(self, *args, **kwargs): ...
    def bind_execute_many(self, *args, **kwargs): ...
    def close(self, *args, **kwargs): ...
    def close_statement(self, *args, **kwargs): ...
    def copy_in(self, *args, **kwargs): ...
    def copy_out(self, *args, **kwargs): ...
    def execute(self, *args, **kwargs): ...
    def get_server_pid(self, *args, **kwargs): ...
    def get_settings(self, *args, **kwargs): ...
    def is_closed(self, *args, **kwargs): ...
    def is_connected(self, *args, **kwargs): ...
    def is_in_transaction(self, *args, **kwargs): ...
    def pause_writing(self, *args, **kwargs): ...
    def prepare(self, *args, **kwargs): ...
    def query(self, *args, **kwargs): ...
    def resume_writing(self, *args, **kwargs): ...
    def set_connection(self, *args, **kwargs): ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class BufferError(Exception): ...

class Codec:
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class ConnectionSettings:
    def __init__(self, *args, **kwargs) -> None: ...
    def add_python_codec(self, *args, **kwargs): ...
    def get_data_codec(self, *args, **kwargs): ...
    def get_text_codec(self, *args, **kwargs): ...
    def register_data_types(self, *args, **kwargs): ...
    def remove_python_codec(self, *args, **kwargs): ...
    def set_builtin_type_codec(self, *args, **kwargs): ...
    def __getattr__(self, name): ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class DataCodecConfig:
    def __init__(self, *args, **kwargs) -> None: ...
    def _set_builtin_type_codec(self, *args, **kwargs): ...
    def add_python_codec(self, *args, **kwargs): ...
    def add_types(self, *args, **kwargs): ...
    def clear_type_cache(self, *args, **kwargs): ...
    def declare_fallback_codec(self, *args, **kwargs): ...
    def remove_python_codec(self, *args, **kwargs): ...
    def set_builtin_type_codec(self, *args, **kwargs): ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class FastReadBuffer:
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class Memory:
    def __init__(self, *args, **kwargs) -> None: ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class PreparedStatementState:
    closed: Any = ...
    name: Any = ...
    query: Any = ...
    refs: Any = ...
    def __init__(self, *args, **kwargs): ...
    def _get_attributes(self, *args, **kwargs): ...
    def _get_parameters(self, *args, **kwargs): ...
    def _init_types(self, *args, **kwargs): ...
    def attach(self, *args, **kwargs): ...
    def detach(self, *args, **kwargs): ...
    def mark_closed(self, *args, **kwargs): ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class Protocol(BaseProtocol, asyncio.Protocol): ...

class ReadBuffer:
    def __init__(self, *args, **kwargs): ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...


_VT = TypeVar('_VT', covariant=True)


class Record(TEProtocol[_VT]):
    def items(self) -> Iterator[Tuple[str, _VT]]: ...
    def keys(self) -> Iterator[str]: ...
    def values(self) -> Iterator[_VT]: ...
    @overload
    def __getitem__(self, index: int) -> _VT: ...
    @overload
    def __getitem__(self, index: str) -> _VT: ...
    def __iter__(self) -> Iterator[_VT]: ...
    def __contains__(self, x: object) -> bool: ...
    def __len__(self) -> int: ...

class Timer: ...

class WriteBuffer:
    __pyx_vtable__ = ... # type: Any
    def __init__(self, *args, **kwargs): ...
    def __reduce__(self): ...
    def __setstate__(self, state): ...

class _Dec:
    imag = ... # type: Any
    real = ... # type: Any
    def __init__(self, *args, **kwargs): ...
    def adjusted(self, *args, **kwargs): ...
    def as_integer_ratio(self, *args, **kwargs): ...
    def as_tuple(self, *args, **kwargs): ...
    def canonical(self, *args, **kwargs): ...
    def compare(self, *args, **kwargs): ...
    def compare_signal(self, *args, **kwargs): ...
    def compare_total(self, *args, **kwargs): ...
    def compare_total_mag(self, *args, **kwargs): ...
    def conjugate(self, *args, **kwargs): ...
    def copy_abs(self, *args, **kwargs): ...
    def copy_negate(self, *args, **kwargs): ...
    def copy_sign(self, *args, **kwargs): ...
    def exp(self, *args, **kwargs): ...
    def fma(self, *args, **kwargs): ...
    @classmethod
    def from_float(cls, *args, **kwargs): ...
    def is_canonical(self, *args, **kwargs): ...
    def is_finite(self, *args, **kwargs): ...
    def is_infinite(self, *args, **kwargs): ...
    def is_nan(self, *args, **kwargs): ...
    def is_normal(self, *args, **kwargs): ...
    def is_qnan(self, *args, **kwargs): ...
    def is_signed(self, *args, **kwargs): ...
    def is_snan(self, *args, **kwargs): ...
    def is_subnormal(self, *args, **kwargs): ...
    def is_zero(self, *args, **kwargs): ...
    def ln(self, *args, **kwargs): ...
    def log10(self, *args, **kwargs): ...
    def logb(self, *args, **kwargs): ...
    def logical_and(self, *args, **kwargs): ...
    def logical_invert(self, *args, **kwargs): ...
    def logical_or(self, *args, **kwargs): ...
    def logical_xor(self, *args, **kwargs): ...
    def max(self, *args, **kwargs): ...
    def max_mag(self, *args, **kwargs): ...
    def min(self, *args, **kwargs): ...
    def min_mag(self, *args, **kwargs): ...
    def next_minus(self, *args, **kwargs): ...
    def next_plus(self, *args, **kwargs): ...
    def next_toward(self, *args, **kwargs): ...
    def normalize(self, *args, **kwargs): ...
    def number_class(self, *args, **kwargs): ...
    def quantize(self, *args, **kwargs): ...
    def radix(self, *args, **kwargs): ...
    def remainder_near(self, *args, **kwargs): ...
    def rotate(self, *args, **kwargs): ...
    def same_quantum(self, *args, **kwargs): ...
    def scaleb(self, *args, **kwargs): ...
    def shift(self, *args, **kwargs): ...
    def sqrt(self, *args, **kwargs): ...
    def to_eng_string(self, *args, **kwargs): ...
    def to_integral(self, *args, **kwargs): ...
    def to_integral_exact(self, *args, **kwargs): ...
    def to_integral_value(self, *args, **kwargs): ...
    def __abs__(self, *args, **kwargs): ...
    def __add__(self, other): ...
    def __bool__(self): ...
    def __ceil__(self, *args, **kwargs): ...
    def __complex__(self): ...
    def __copy__(self): ...
    def __deepcopy__(self): ...
    def __divmod__(self, other): ...
    def __eq__(self, other): ...
    def __float__(self): ...
    def __floor__(self, *args, **kwargs): ...
    def __floordiv__(self, other): ...
    def __format__(self, *args, **kwargs): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __hash__(self): ...
    def __int__(self): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __mod__(self, other): ...
    def __mul__(self, other): ...
    def __ne__(self, other): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rdivmod__(self, other): ...
    def __reduce__(self): ...
    def __rfloordiv__(self, other): ...
    def __rmod__(self, other): ...
    def __rmul__(self, other): ...
    def __round__(self, *args, **kwargs): ...
    def __rpow__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __sizeof__(self): ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...
    def __trunc__(self): ...

class _UUID:
    __init__ = ... # type: Any
    bytes = ... # type: Any
    bytes_le = ... # type: Any
    clock_seq = ... # type: Any
    clock_seq_hi_variant = ... # type: Any
    clock_seq_low = ... # type: Any
    fields = ... # type: Any
    hex = ... # type: Any
    node = ... # type: Any
    time = ... # type: Any
    time_hi_version = ... # type: Any
    time_low = ... # type: Any
    time_mid = ... # type: Any
    urn = ... # type: Any
    variant = ... # type: Any
    version = ... # type: Any
    __eq__ = ... # type: Any
    __ge__ = ... # type: Any
    __gt__ = ... # type: Any
    __hash__ = ... # type: Any
    __int__ = ... # type: Any
    __le__ = ... # type: Any
    __lt__ = ... # type: Any
    __setattr__ = ... # type: Any

class timedelta:
    days = ... # type: Any
    max = ... # type: Any
    microseconds = ... # type: Any
    min = ... # type: Any
    resolution = ... # type: Any
    seconds = ... # type: Any
    def __init__(self, *args, **kwargs): ...
    def total_seconds(self, *args, **kwargs): ...
    def __abs__(self, *args, **kwargs): ...
    def __add__(self, other): ...
    def __bool__(self): ...
    def __divmod__(self, other): ...
    def __eq__(self, other): ...
    def __floordiv__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __hash__(self): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __mod__(self, other): ...
    def __mul__(self, other): ...
    def __ne__(self, other): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __radd__(self, other): ...
    def __rdivmod__(self, other): ...
    def __reduce__(self): ...
    def __rfloordiv__(self, other): ...
    def __rmod__(self, other): ...
    def __rmul__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...
